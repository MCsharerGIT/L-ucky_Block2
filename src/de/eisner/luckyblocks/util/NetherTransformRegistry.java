package de.eisner.luckyblocks.util;

import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.Tag;
import org.bukkit.block.Biome;
import org.bukkit.block.Block;
import org.bukkit.block.data.BlockData;
import org.bukkit.block.data.Waterlogged;
import org.bukkit.Location;

import java.util.*;

//This class has entirely been generated by ChatGPT 5 Thinking
public final class NetherTransformRegistry {

    private NetherTransformRegistry() {}

    // Explicit overrides win first (exact Material -> Material)
    private static final Map<Material, Material> OVERRIDES = new EnumMap<>(Material.class);

    // Map specific Overworld wood families -> which Nether wood (crimson/warped) they become
    private static final Set<String> TO_CRIMSON = new HashSet<>();
    private static final Set<String> TO_WARPED  = new HashSet<>();

    // Themes we can paint the world with, chosen by Overworld biome
    public enum Theme { WASTES, CRIMSON, WARPED, SOUL, BASALT }


    /** Pick one nether theme from the Overworld biome at this location. Call once per effect. */
    public static Theme chooseThemeAt(Location loc) {
        if (loc == null || loc.getWorld() == null) return Theme.WASTES;
        try {
            return themeFor(loc.getBlock().getBiome());
        } catch (Throwable ignored) {
            return Theme.WASTES;
        }
    }

    // Call once in onEnable()
    public static void registerDefaults() {
        OVERRIDES.clear();
        TO_CRIMSON.clear();
        TO_WARPED.clear();

        // ------------------------------
        // LOG / LEAF / PLANK FAMILIES
        // ------------------------------
        // Warm woods -> CRIMSON
        addCrimsonFamily("OAK");
        addCrimsonFamily("BIRCH");
        addCrimsonFamily("DARK_OAK");
        addCrimsonFamily("ACACIA");
        addCrimsonFamily("JUNGLE");
        addCrimsonFamily("CHERRY");
        // Cool/blueish or swampy -> WARPED
        addWarpedFamily("SPRUCE");
        addWarpedFamily("MANGROVE");
        // Bamboo (not a log) – map planks & block
        putIfExists("BAMBOO_BLOCK", Material.WARPED_STEM);
        putIfExists("BAMBOO_PLANKS", Material.WARPED_PLANKS);
        putIfExists("BAMBOO_MOSAIC", Material.WARPED_PLANKS);

        // ------------------------------
        // STONE / COBBLE / BRICKS
        // ------------------------------


        putAll(List.of(Material.COBBLESTONE, Material.MOSSY_COBBLESTONE), Material.BLACKSTONE);
        putAll(List.of(
                Material.STONE_BRICKS, Material.CRACKED_STONE_BRICKS, Material.MOSSY_STONE_BRICKS, Material.CHISELED_STONE_BRICKS
        ), Material.POLISHED_BLACKSTONE_BRICKS);

        putAll(List.of(
                Material.BRICKS, Material.CHISELED_SANDSTONE, Material.CUT_SANDSTONE, Material.SANDSTONE, Material.RED_SANDSTONE,
                Material.CUT_RED_SANDSTONE, Material.SMOOTH_SANDSTONE, Material.SMOOTH_RED_SANDSTONE
        ), Material.SMOOTH_BASALT);

        // Deepslate -> Blackstone/Basalt mixture; keep it simple:
        for (Material m : Material.values()) {
            if (m.name().startsWith("DEEPSLATE")) OVERRIDES.put(m, Material.BLACKSTONE);
        }

        // ------------------------------
        // DIRT / GRASS / SOIL
        // ------------------------------
        putAll(List.of(Material.DIRT, Material.COARSE_DIRT, Material.ROOTED_DIRT, Material.MUD), Material.SOUL_SOIL);
        // GRASS_BLOCK / PODZOL / MYCELIUM will be themed -> handled in themed fallback below

        // ------------------------------
        // SAND / GRAVEL / CLAY
        // ------------------------------
        putAll(List.of(Material.SAND, Material.RED_SAND), Material.SOUL_SAND);
        putAll(List.of(Material.GRAVEL, Material.CLAY), Material.MAGMA_BLOCK);

        // ------------------------------
        // ORES (conservative)
        // ------------------------------
        putAll(List.of(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE), Material.NETHER_GOLD_ORE);
        // others -> Quartz (nether default ore)
        putAll(List.of(
                Material.COAL_ORE, Material.IRON_ORE, Material.COPPER_ORE, Material.LAPIS_ORE, Material.REDSTONE_ORE,
                Material.EMERALD_ORE, Material.DIAMOND_ORE,
                Material.DEEPSLATE_COAL_ORE, Material.DEEPSLATE_IRON_ORE, Material.DEEPSLATE_COPPER_ORE,
                Material.DEEPSLATE_LAPIS_ORE, Material.DEEPSLATE_REDSTONE_ORE, Material.DEEPSLATE_EMERALD_ORE,
                Material.DEEPSLATE_DIAMOND_ORE
        ), Material.NETHER_QUARTZ_ORE);

        // ------------------------------
        // FLUIDS & WATER VARIANTS
        // ------------------------------
        OVERRIDES.put(Material.WATER, Material.LAVA);
        putIfExists("BUBBLE_COLUMN", Material.LAVA);
        putIfExists("KELP", Material.NETHER_SPROUTS);
        putIfExists("KELP_PLANT", Material.NETHER_SPROUTS);
        putIfExists("SEAGRASS", Material.NETHER_SPROUTS);
        putIfExists("TALL_SEAGRASS", Material.NETHER_SPROUTS);
        putIfExists("WATER_CAULDRON", Material.LAVA_CAULDRON);

        // ------------------------------
        // ICE / SNOW
        // ------------------------------
        putAllExisting(List.of("ICE", "PACKED_ICE", "BLUE_ICE", "FROSTED_ICE"), Material.MAGMA_BLOCK);
        putAll(List.of(Material.SNOW, Material.SNOW_BLOCK), Material.SOUL_SAND);
        putIfExists("POWDER_SNOW", Material.SOUL_SAND);
        putIfExists("POWDER_SNOW_CAULDRON", Material.LAVA_CAULDRON);

        // ------------------------------
        // PLANTS / FOLIAGE
        // ------------------------------
        putAllExisting(List.of(
                "GRASS", "TALL_GRASS", "FERN", "LARGE_FERN", "DEAD_BUSH", "LILY_PAD"
        ), Material.NETHER_SPROUTS);

        // Flowers -> theme will pick roots; default to crimson roots
        for (Material m : Material.values()) {
            if (m.name().endsWith("_FLOWER")) OVERRIDES.put(m, Material.CRIMSON_ROOTS);
        }
        putIfExists("SUNFLOWER", Material.CRIMSON_ROOTS);
        putIfExists("PEONY", Material.CRIMSON_ROOTS);
        putIfExists("ROSE_BUSH", Material.CRIMSON_ROOTS);
        putIfExists("LILAC", Material.CRIMSON_ROOTS);
        putIfExists("WITHER_ROSE", Material.CRIMSON_ROOTS);
        putIfExists("SHORT_GRASS", Material.NETHER_SPROUTS); // 1.21+
        putIfExists("GRASS",       Material.NETHER_SPROUTS); // legacy name if present
        putIfExists("TALL_GRASS",  Material.NETHER_SPROUTS);
        putIfExists("FERN",        Material.NETHER_SPROUTS);
        putIfExists("LARGE_FERN",  Material.NETHER_SPROUTS);
        putIfExists("LEAF_LITTER", Material.NETHER_SPROUTS); // 1.21
        putIfExists("MOSS_CARPET", Material.NETHER_SPROUTS);
        putIfExists("PINK_PETALS", Material.NETHER_SPROUTS);
        putIfExists("HANGING_ROOTS", Material.NETHER_SPROUTS);
        putIfExists("SMALL_DRIPLEAF", Material.CRIMSON_ROOTS);
        putIfExists("BIG_DRIPLEAF",   Material.WARPED_ROOTS);



        // Vines / sugarcane
        putIfExists("VINE", Material.WEEPING_VINES);
        putIfExists("SUGAR_CANE", Material.WEEPING_VINES);

        // Mushrooms -> Nether mushrooms
        putAll(List.of(Material.BROWN_MUSHROOM), Material.WARPED_FUNGUS);
        putAll(List.of(Material.RED_MUSHROOM), Material.CRIMSON_FUNGUS);

        // Farm blocks
        putIfExists("FARMLAND", Material.SOUL_SAND);
        putAllExisting(List.of("WHEAT", "CARROTS", "POTATOES", "BEETROOTS"), Material.NETHER_WART);
        putIfExists("NETHER_WART", Material.NETHER_WART); // unchanged

        // ------------------------------
        // LIGHTS / TORCHES / LANTERNS
        // ------------------------------
        putIfExists("TORCH", Material.SOUL_TORCH);
        putIfExists("WALL_TORCH", Material.SOUL_WALL_TORCH);
        putIfExists("LANTERN", Material.SOUL_LANTERN);
        putIfExists("CAMPFIRE", Material.SOUL_CAMPFIRE);
        putIfExists("SOUL_CAMPFIRE", Material.SOUL_CAMPFIRE);
        putIfExists("SEA_LANTERN", Material.SHROOMLIGHT);

        // ------------------------------
        // SPECIALS
        // ------------------------------
        putAll(List.of(Material.OBSIDIAN), Material.CRYING_OBSIDIAN);
        putAll(List.of(Material.BEDROCK), Material.BEDROCK); // don't change

        registerStoneMappings();

    }

    // --- Public API ---

    /** Returns the replacement for the given block & biome. */
    public static Material getReplacement(Block block, Theme forcedTheme) {
        if (block == null) return Material.NETHERRACK;

        Material original = block.getType();
        Theme theme = (forcedTheme != null) ? forcedTheme : themeFor(block.getBiome());

        // 1) Wood first (logs/wood/leaves/planks)
        if (isWoodLike(original)) {
            Material themed = mapWoodByTheme(original, theme);
            if (themed != null) return themed;
        }

        // 2) Vegetation first (grass/flowers/ferns/saplings/moss/petals/kelp/seagrass/vines/mushrooms/leaf_litter)
        if (isVegetation(original)) {
            return mapVegetationByTheme(block, theme);
        }

        // 3) Exact overrides (non-wood, non-veg)
        Material m = OVERRIDES.get(original);
        if (m != null) return m;

        // 4) Family-based (non-wood leftovers; wood already handled)
        Material familyMapped = mapWoodFamily(original);
        if (familyMapped != null) return familyMapped;

        // 5) Ground by theme
        if (isGrassSoil(original)) {
            return switch (theme) {
                case CRIMSON -> Material.CRIMSON_NYLIUM;
                case WARPED  -> Material.WARPED_NYLIUM;
                case SOUL    -> Material.SOUL_SOIL;
                case BASALT  -> Material.BASALT;
                default      -> Material.NETHERRACK;
            };
        }

        // 6) Vines by theme (if something slipped through)
        if (match("VINE", original)) {
            return (theme == Theme.WARPED) ? Material.TWISTING_VINES : Material.WEEPING_VINES;
        }

        // 7) Stone-like by theme
        Material stoneMapped = mapStoneDeterministic(original, theme);
        if (stoneMapped != null) return stoneMapped;


        // 8) Default substrate
        return Material.NETHERRACK;
    }


    /** If a block is waterlogged, remove waterlog (so “all water types” are handled). */
    public static void dryIfWaterlogged(Block block) {
        BlockData data = block.getBlockData();
        if (data instanceof Waterlogged wl && wl.isWaterlogged()) {
            wl.setWaterlogged(false);
            block.setBlockData(wl, false);
        }
    }

    // --- Theme selection by Overworld biome ---
    public static Theme themeFor(Biome b) {
        if (b == null) return Theme.WASTES;

        // Forests / plains -> CRIMSON
        switch (b) {
            case PLAINS, MEADOW, SUNFLOWER_PLAINS, CHERRY_GROVE ->
            { return Theme.WASTES; }
            // Cold / snowy -> SOUL
            case SNOWY_PLAINS, SNOWY_TAIGA, GROVE, SNOWY_SLOPES, JAGGED_PEAKS, FROZEN_PEAKS, STONY_PEAKS, FROZEN_RIVER, FROZEN_OCEAN ->
            { return Theme.SOUL; }
            // Swampy / mangrove / water-logged -> WARPED
            case SWAMP, MANGROVE_SWAMP, RIVER, OCEAN,FOREST,BIRCH_FOREST, WARM_OCEAN, LUKEWARM_OCEAN, DEEP_OCEAN, COLD_OCEAN, DEEP_COLD_OCEAN, DEEP_FROZEN_OCEAN, BEACH ->
            { return Theme.WARPED; }
            // Rocky / badlands -> BASALT
            case WINDSWEPT_HILLS, WINDSWEPT_FOREST, WINDSWEPT_GRAVELLY_HILLS, STONY_SHORE, BADLANDS, ERODED_BADLANDS, WOODED_BADLANDS ->
            { return Theme.BASALT; }
            // Jungles / savannas -> CRIMSON (warm)
            case JUNGLE, SPARSE_JUNGLE, BAMBOO_JUNGLE, SAVANNA, FLOWER_FOREST,DARK_FOREST, SAVANNA_PLATEAU, WINDSWEPT_SAVANNA ->
            { return Theme.CRIMSON; }
            // Mushrooms -> WARPED (weird vibe)
            case MUSHROOM_FIELDS -> { return Theme.WARPED; }
            default -> { return Theme.WASTES; }
        }
    }

    // --- Helpers ---

    private static final Random RNG = new Random();

    private static Material chooseWeighted(LinkedHashMap<Material, Integer> palette) {
        int total = 0;
        for (int w : palette.values()) total += w;
        int roll = RNG.nextInt(Math.max(1, total));
        for (Map.Entry<Material, Integer> e : palette.entrySet()) {
            roll -= e.getValue();
            if (roll < 0) return e.getKey();
        }
        return palette.keySet().iterator().next(); // fallback
    }

    private static boolean isStoneLike(Material m) {
        String n = m.name();
        // raw stones + families + variants
        return n.contains("STONE") || n.contains("TUFF") || n.contains("CALCITE") || n.contains("DEEPSLATE")
                || n.endsWith("_STAIRS") || n.endsWith("_SLAB") || n.endsWith("_WALL")
                || n.contains("BRICK") || n.contains("MOSSY_COBBLE") || n.contains("COBBLE");
    }

    private static Material mapStoneByTheme(Material original, Theme theme) {
        // 1) choose a base block from a theme palette
        LinkedHashMap<Material, Integer> pal = new LinkedHashMap<>();

        switch (theme) {
            case BASALT -> {
                // heavy basalt deltas feel
                pal.put(Material.BASALT, 50);
                pal.put(Material.BLACKSTONE, 30);
                pal.put(Material.SMOOTH_BASALT, 15);
                pal.put(Material.MAGMA_BLOCK, 5);
            }
            case SOUL -> {
                // soul valley: rocky but with some soul substrate
                pal.put(Material.BLACKSTONE, 35);
                pal.put(Material.BASALT, 25);
                pal.put(Material.SOUL_SAND, 20);
                pal.put(Material.SOUL_SOIL, 15);
                pal.put(Material.MAGMA_BLOCK, 5);
            }
            case CRIMSON -> {
                // warm crimson: netherrack + nether bricks + some blackstone/basalt
                pal.put(Material.NETHERRACK, 40);
                pal.put(Material.NETHER_BRICKS, 25);
                pal.put(Material.BLACKSTONE, 25);
                pal.put(Material.BASALT, 10);
            }
            case WARPED -> {
                // cooler warped: more blackstone/basalt, a bit of netherrack
                pal.put(Material.BLACKSTONE, 40);
                pal.put(Material.BASALT, 30);
                pal.put(Material.NETHERRACK, 25);
                pal.put(Material.MAGMA_BLOCK, 5);
            }
            default /* WASTES */ -> {
                pal.put(Material.NETHERRACK, 40);
                pal.put(Material.BLACKSTONE, 30);
                pal.put(Material.BASALT, 20);
                pal.put(Material.MAGMA_BLOCK, 10);
            }
        }

        Material base = chooseWeighted(pal);
        return applyStoneVariant(base, original);
    }

    /** Keep shape (STAIRS/SLAB/WALL) if possible; otherwise fallback sensibly. */
    private static Material applyStoneVariant(Material base, Material original) {
        String n = original.name();
        String baseName = base.name();

        if (n.endsWith("_STAIRS")) {
            Material target = Material.matchMaterial(baseName + "_STAIRS");
            if (target != null) return target;
            // best available fallback stairs
            Material fb = Material.matchMaterial("BLACKSTONE_STAIRS");
            if (fb != null) return fb;
        }
        if (n.endsWith("_SLAB")) {
            Material target = Material.matchMaterial(baseName + "_SLAB");
            if (target != null) return target;
            Material fb = Material.matchMaterial("BLACKSTONE_SLAB");
            if (fb != null) return fb;
        }
        if (n.endsWith("_WALL")) {
            Material target = Material.matchMaterial(baseName + "_WALL");
            if (target != null) return target;
            Material fb = Material.matchMaterial("BLACKSTONE_WALL");
            if (fb != null) return fb;
        }
        // bricks -> try a brickier substitute
        if (n.contains("BRICK")) {
            Material target = (base == Material.NETHER_BRICKS) ? Material.NETHER_BRICKS : Material.POLISHED_BLACKSTONE_BRICKS;
            return target;
        }
        // cobble -> blackstone family looks closest
        if (n.contains("COBBLE")) return Material.BLACKSTONE;

        return base;
    }

    // --- Vegetation helpers ---

    private static boolean isVegetation(Material m) {
        String n = m.name();
        if ((n.contains("GRASS") && n != "GRASS_BLOCK") || n.contains("FERN") || n.contains("ROOTS") || n.contains("MOSS")
                || n.endsWith("_FLOWER") || n.endsWith("_SAPLING") || n.contains("DRIPLEAF")
                || n.contains("SEAGRASS") || n.contains("KELP") || n.equals("LEAF_LITTER")
                || n.equals("LILY_PAD") || n.contains("VINE") || n.contains("MUSHROOM")) {
            return true;
        }
        // Tags (guarded to avoid version issues)
        try { if (Tag.SMALL_FLOWERS.isTagged(m)) return true; } catch (Throwable ignored) {}
        try { if (Tag.TALL_FLOWERS.isTagged(m))  return true; } catch (Throwable ignored) {}
        try { if (Tag.SAPLINGS.isTagged(m))      return true; } catch (Throwable ignored) {}
        return false;
    }

    private static boolean canSupportTwisting(Block block) {
        // Twisting vines need a solid block below
        return block.getRelative(0, -1, 0).getType().isSolid();
    }

    private static boolean canSupportWeeping(Block block) {
        // Weeping vines need a solid block above
        return block.getRelative(0, 1, 0).getType().isSolid();
    }

    private static boolean isSoulBase(Block block) {
        Material below = block.getRelative(0, -1, 0).getType();
        return (below == Material.SOUL_SAND || below == Material.SOUL_SOIL);
    }

    /** Theme-first vegetation mapping with a bit of variety + placement checks. */
    private static Material mapVegetationByTheme(Block block, Theme theme) {
        Material original = block.getType();
        switch (theme) {
            case WARPED -> {
                // Warped: warped roots (most), warped fungus (some), twisting vines (rare if allowed)
                int r = RNG.nextInt(100);
                if (r < 70) return Material.WARPED_ROOTS;
                if (r < 95) return Material.WARPED_FUNGUS;
                return canSupportTwisting(block) ? Material.TWISTING_VINES : Material.WARPED_ROOTS;
            }
            case CRIMSON -> {
                // Crimson: crimson roots (most), crimson fungus (some), weeping vines (rare if allowed)
                int r = RNG.nextInt(100);
                if (r < 70) return Material.CRIMSON_ROOTS;
                if (r < 95) return Material.CRIMSON_FUNGUS;
                return canSupportWeeping(block) ? Material.WEEPING_VINES : Material.CRIMSON_ROOTS;
            }
            case SOUL -> {
                // Soul Sand Valley: mostly barren; sprouts sometimes; soul fire if base is soul sand/soil
                int r = RNG.nextInt(100);
                if (isSoulBase(block) && r < 15) return Material.SOUL_FIRE; // place only when base supports it
                return (r < 80) ? Material.NETHER_SPROUTS : Material.AIR;   // sparse
            }
            case BASALT -> {
                // Basalt Deltas: almost no vegetation; sometimes sprouts; sometimes fire
                int r = RNG.nextInt(100);
                if (r < 10) return Material.NETHER_SPROUTS;
                if (r < 15 && block.getRelative(0, -1, 0).getType().isSolid()) return Material.FIRE;
                return Material.AIR; // remove most plants
            }
            default /* WASTES */ -> {
                return Material.FIRE;
            }
        }
    }

    private static boolean isWoodLike(Material m) {
        String n = m.name();
        return Tag.LOGS.isTagged(m) || Tag.PLANKS.isTagged(m)
                || n.endsWith("_WOOD") || n.endsWith("_LOG")
                || n.endsWith("_PLANKS") || n.endsWith("_LEAVES");
    }

    private static Material mapWoodByTheme(Material original, Theme theme) {
        if (theme == null) return null;
        String n = original.name();

        // Leaves
        if (Tag.LEAVES.isTagged(original) || n.endsWith("_LEAVES")) {
            return (theme == Theme.WARPED) ? Material.WARPED_WART_BLOCK : Material.NETHER_WART_BLOCK;
        }

        // Logs / Woods (including stripped variants)
        boolean stripped = n.contains("STRIPPED");
        boolean isLog    = n.endsWith("_LOG");
        boolean isWood   = n.endsWith("_WOOD");

        if (isLog || isWood) {
            if (theme == Theme.WARPED) {
                if (stripped && isLog)  return Material.STRIPPED_WARPED_STEM;
                if (stripped && isWood) return Material.STRIPPED_WARPED_HYPHAE;
                if (isLog)              return Material.WARPED_STEM;
                if (isWood)             return Material.WARPED_HYPHAE;
            } else { // CRIMSON or any non-warped theme defaults to crimson wood
                if (stripped && isLog)  return Material.STRIPPED_CRIMSON_STEM;
                if (stripped && isWood) return Material.STRIPPED_CRIMSON_HYPHAE;
                if (isLog)              return Material.CRIMSON_STEM;
                if (isWood)             return Material.CRIMSON_HYPHAE;
            }
        }

        // Planks
        if (Tag.PLANKS.isTagged(original) || n.endsWith("_PLANKS")) {
            return (theme == Theme.WARPED) ? Material.WARPED_PLANKS : Material.CRIMSON_PLANKS;
        }

        return null;
    }


    private static boolean isGrassSoil(Material m) {
        return m == Material.GRASS_BLOCK || m == Material.PODZOL || m == Material.MYCELIUM ||
                m == Material.DIRT || m == Material.COARSE_DIRT || m == Material.ROOTED_DIRT || m == Material.MUD;
    }


    private static boolean match(String needle, Material m) {
        return m.name().equals(needle) || m.name().endsWith("_" + needle);
    }

    private static void putAll(Collection<Material> from, Material to) {
        for (Material m : from) OVERRIDES.put(m, to);
    }

    private static void putIfExists(String matName, Material to) {
        Material m = Material.matchMaterial(matName);
        if (m != null) OVERRIDES.put(m, to);
    }

    private static void putAllExisting(Collection<String> names, Material to) {
        for (String n : names) putIfExists(n, to);
    }

    private static void addCrimsonFamily(String base) { addWoodFamily(base, true); }
    private static void addWarpedFamily(String base)  { addWoodFamily(base, false); }

    private static void addWoodFamily(String base, boolean crimson) {
        Material stem           = crimson ? Material.CRIMSON_STEM            : Material.WARPED_STEM;
        Material hyphae         = crimson ? Material.CRIMSON_HYPHAE          : Material.WARPED_HYPHAE;
        Material strippedStem   = crimson ? Material.STRIPPED_CRIMSON_STEM   : Material.STRIPPED_WARPED_STEM;
        Material strippedHyphae = crimson ? Material.STRIPPED_CRIMSON_HYPHAE : Material.STRIPPED_WARPED_HYPHAE;
        Material planks         = crimson ? Material.CRIMSON_PLANKS          : Material.WARPED_PLANKS;
        Material leavesWart     = crimson ? Material.NETHER_WART_BLOCK       : Material.WARPED_WART_BLOCK;

        mapIfExists(base + "_LOG", stem);
        mapIfExists("STRIPPED_" + base + "_LOG", strippedStem);
        mapIfExists(base + "_WOOD", hyphae);
        mapIfExists("STRIPPED_" + base + "_WOOD", strippedHyphae);
        mapIfExists(base + "_PLANKS", planks);
        mapIfExists(base + "_LEAVES", leavesWart);

        if (crimson) TO_CRIMSON.add(base); else TO_WARPED.add(base);
    }

    private static void mapIfExists(String matName, Material to) {
        Material m = Material.matchMaterial(matName);
        if (m != null) OVERRIDES.put(m, to);
    }

    /** If a specific log/plank/leaf wasn’t explicitly mapped above, try smart mapping via tags/names. */
    private static Material mapWoodFamily(Material original) {
        String n = original.name();

        // Leaves -> wart blocks handled later if not covered here
        if (Tag.LEAVES.isTagged(original)) return null;

        // Logs / Woods
        if (Tag.LOGS.isTagged(original) || n.endsWith("_WOOD")) {
            // Try by family name prefix
            for (String fam : TO_CRIMSON) {
                if (n.startsWith(fam + "_") || n.contains("_" + fam + "_")) return familyToNether(original, true);
            }
            for (String fam : TO_WARPED) {
                if (n.startsWith(fam + "_") || n.contains("_" + fam + "_")) return familyToNether(original, false);
            }
        }

        // Planks
        if (Tag.PLANKS.isTagged(original)) {
            for (String fam : TO_CRIMSON) if (n.startsWith(fam + "_")) return Material.CRIMSON_PLANKS;
            for (String fam : TO_WARPED)  if (n.startsWith(fam + "_")) return Material.WARPED_PLANKS;
        }

        return null;
    }

    private static Material familyToNether(Material original, boolean crimson) {
        String n = original.name();
        if (n.contains("STRIPPED") && n.endsWith("_LOG"))  return crimson ? Material.STRIPPED_CRIMSON_STEM   : Material.STRIPPED_WARPED_STEM;
        if (n.contains("STRIPPED") && n.endsWith("_WOOD")) return crimson ? Material.STRIPPED_CRIMSON_HYPHAE : Material.STRIPPED_WARPED_HYPHAE;
        if (n.endsWith("_LOG"))                             return crimson ? Material.CRIMSON_STEM           : Material.WARPED_STEM;
        if (n.endsWith("_WOOD"))                            return crimson ? Material.CRIMSON_HYPHAE         : Material.WARPED_HYPHAE;
        if (n.endsWith("_PLANKS"))                          return crimson ? Material.CRIMSON_PLANKS         : Material.WARPED_PLANKS;
        if (n.endsWith("_LEAVES"))                          return crimson ? Material.NETHER_WART_BLOCK      : Material.WARPED_WART_BLOCK;
        return crimson ? Material.CRIMSON_STEM : Material.WARPED_STEM;
    }

    // ---------------- Stone: deterministic theme maps (no RNG) ----------------
    private static final EnumMap<Theme, EnumMap<Material, Material>> STONE_MAP = new EnumMap<>(Theme.class);

    private static void registerStoneMappings() {
        STONE_MAP.clear();

        // Helper to build a theme table
        EnumMap<Material, Material> t;

        // ===== CRIMSON (warm / red) =====
        t = new EnumMap<>(Material.class);
        t.put(Material.STONE,                 Material.NETHERRACK);
        t.put(Material.SMOOTH_STONE,          Material.NETHERRACK);
        t.put(Material.COBBLESTONE,           Material.BLACKSTONE);
        t.put(Material.MOSSY_COBBLESTONE,     Material.BLACKSTONE);
        t.put(Material.GRANITE,               Material.NETHER_BRICKS);
        t.put(Material.DIORITE,               Material.BLACKSTONE);
        t.put(Material.ANDESITE,              Material.BASALT);
        t.put(Material.CALCITE,               Material.QUARTZ_BLOCK);
        t.put(Material.TUFF,                  Material.SMOOTH_BASALT);
        // Deepslate family (base blocks)
        putIfExistsMap(t, "DEEPSLATE",        Material.BLACKSTONE);

        // Stone bricks family
        t.put(Material.STONE_BRICKS,              Material.NETHER_BRICKS);
        t.put(Material.CRACKED_STONE_BRICKS,      Material.CRACKED_NETHER_BRICKS);
        t.put(Material.MOSSY_STONE_BRICKS,        Material.NETHER_BRICKS);
        t.put(Material.CHISELED_STONE_BRICKS,     Material.CHISELED_POLISHED_BLACKSTONE);
        STONE_MAP.put(Theme.CRIMSON, t);

        // ===== WARPED (cool / blue) =====
        t = new EnumMap<>(Material.class);
        t.put(Material.STONE,                 Material.BLACKSTONE);
        t.put(Material.SMOOTH_STONE,          Material.BLACKSTONE);
        t.put(Material.COBBLESTONE,           Material.BLACKSTONE);
        t.put(Material.MOSSY_COBBLESTONE,     Material.BLACKSTONE);
        t.put(Material.GRANITE,               Material.BASALT);
        t.put(Material.DIORITE,               Material.BLACKSTONE);
        t.put(Material.ANDESITE,              Material.SMOOTH_BASALT);
        t.put(Material.CALCITE,               Material.QUARTZ_BLOCK);
        t.put(Material.TUFF,                  Material.BASALT);
        putIfExistsMap(t, "DEEPSLATE",        Material.BLACKSTONE);

        t.put(Material.STONE_BRICKS,              Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CRACKED_STONE_BRICKS,      Material.CRACKED_POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.MOSSY_STONE_BRICKS,        Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CHISELED_STONE_BRICKS,     Material.CHISELED_POLISHED_BLACKSTONE);
        STONE_MAP.put(Theme.WARPED, t);

        // ===== BASALT DELTAS (rocky) =====
        t = new EnumMap<>(Material.class);
        t.put(Material.STONE,                 Material.BASALT);
        t.put(Material.SMOOTH_STONE,          Material.SMOOTH_BASALT);
        t.put(Material.COBBLESTONE,           Material.BLACKSTONE);
        t.put(Material.MOSSY_COBBLESTONE,     Material.BLACKSTONE);
        t.put(Material.GRANITE,               Material.BASALT);
        t.put(Material.DIORITE,               Material.SMOOTH_BASALT);
        t.put(Material.ANDESITE,              Material.POLISHED_BASALT);
        t.put(Material.CALCITE,               Material.SMOOTH_BASALT);
        t.put(Material.TUFF,                  Material.BASALT);
        putIfExistsMap(t, "DEEPSLATE",        Material.BLACKSTONE);

        t.put(Material.STONE_BRICKS,              Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CRACKED_STONE_BRICKS,      Material.CRACKED_POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.MOSSY_STONE_BRICKS,        Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CHISELED_STONE_BRICKS,     Material.CHISELED_POLISHED_BLACKSTONE);
        STONE_MAP.put(Theme.BASALT, t);

        // ===== SOUL SAND VALLEY (barren / bone) =====
        t = new EnumMap<>(Material.class);
        t.put(Material.STONE,                 Material.BLACKSTONE);
        t.put(Material.SMOOTH_STONE,          Material.BLACKSTONE);
        t.put(Material.COBBLESTONE,           Material.BLACKSTONE);
        t.put(Material.MOSSY_COBBLESTONE,     Material.BLACKSTONE);
        t.put(Material.GRANITE,               Material.BASALT);
        t.put(Material.DIORITE,               Material.BLACKSTONE);
        t.put(Material.ANDESITE,              Material.BASALT);
        t.put(Material.CALCITE,               Material.BONE_BLOCK); // bone spikes vibe
        t.put(Material.TUFF,                  Material.BASALT);
        putIfExistsMap(t, "DEEPSLATE",        Material.BLACKSTONE);

        t.put(Material.STONE_BRICKS,              Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CRACKED_STONE_BRICKS,      Material.CRACKED_POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.MOSSY_STONE_BRICKS,        Material.POLISHED_BLACKSTONE_BRICKS);
        t.put(Material.CHISELED_STONE_BRICKS,     Material.CHISELED_POLISHED_BLACKSTONE);
        STONE_MAP.put(Theme.SOUL, t);

        // ===== WASTES (neutral nether) =====
        t = new EnumMap<>(Material.class);
        t.put(Material.STONE,                 Material.NETHERRACK);
        t.put(Material.SMOOTH_STONE,          Material.NETHERRACK);
        t.put(Material.COBBLESTONE,           Material.BLACKSTONE);
        t.put(Material.MOSSY_COBBLESTONE,     Material.BLACKSTONE);
        t.put(Material.GRANITE,               Material.RED_NETHER_BRICKS);
        t.put(Material.DIORITE,               Material.POLISHED_BLACKSTONE);
        t.put(Material.ANDESITE,              Material.BASALT);
        t.put(Material.CALCITE,               Material.QUARTZ_BLOCK);
        t.put(Material.TUFF,                  Material.BASALT);
        putIfExistsMap(t, "DEEPSLATE",        Material.BLACKSTONE);

        t.put(Material.STONE_BRICKS,              Material.NETHER_BRICKS);
        t.put(Material.CRACKED_STONE_BRICKS,      Material.CRACKED_NETHER_BRICKS);
        t.put(Material.MOSSY_STONE_BRICKS,        Material.NETHER_BRICKS);
        t.put(Material.CHISELED_STONE_BRICKS,     Material.CHISELED_POLISHED_BLACKSTONE);
        STONE_MAP.put(Theme.WASTES, t);
    }

    // convenience for mapping whole families by prefix (e.g., DEEPSLATE)
    private static void putIfExistsMap(Map<Material, Material> map, String startsWith, Material to) {
        for (Material m : Material.values()) {
            if (m.name().startsWith(startsWith)) map.put(m, to);
        }
    }

    private static Material mapStoneDeterministic(Material original, Theme theme) {
        EnumMap<Material, Material> table = STONE_MAP.get(theme);
        Material base = (table != null) ? table.get(original) : null;

        // If not explicitly listed, leave to earlier/other logic
        if (base == null) return null;

        // Preserve STAIRS/SLAB/WALL shapes when possible
        return applyStoneVariantDeterministic(base, original);
    }

    // turn base block into the right variant name; handle Mojang name quirks
    private static Material applyStoneVariantDeterministic(Material base, Material original) {
        String o = original.name();
        boolean stairs = o.endsWith("_STAIRS");
        boolean slab   = o.endsWith("_SLAB");
        boolean wall   = o.endsWith("_WALL");

        if (!stairs && !slab && !wall) return base;

        Material candidate = variantOf(base, stairs ? "STAIRS" : slab ? "SLAB" : "WALL");
        if (candidate != null) return candidate;

        // smart fallbacks (families that always have variants)
        if (stairs) {
            Material fb = Material.matchMaterial("BLACKSTONE_STAIRS");
            if (fb != null) return fb;
        }
        if (slab) {
            Material fb = Material.matchMaterial("BLACKSTONE_SLAB");
            if (fb != null) return fb;
        }
        if (wall) {
            Material fb = Material.matchMaterial("BLACKSTONE_WALL");
            if (fb != null) return fb;
        }
        return base;
    }

    // resolve variant material names for special families
    private static Material variantOf(Material base, String variantSuffix) {
        String b = base.name();

        // NETHER_BRICKS & RED_NETHER_BRICKS use singular BRICK in variants
        if (b.equals("NETHER_BRICKS")) {
            return Material.matchMaterial("NETHER_BRICK_" + variantSuffix);
        }
        if (b.equals("RED_NETHER_BRICKS")) {
            return Material.matchMaterial("RED_NETHER_BRICK_" + variantSuffix);
        }
        // POLISHED_BLACKSTONE_BRICKS & CRACKED_... don’t have cracked variants; use BRICK_* variants
        if (b.equals("POLISHED_BLACKSTONE_BRICKS") || b.equals("CRACKED_POLISHED_BLACKSTONE_BRICKS")) {
            return Material.matchMaterial("POLISHED_BLACKSTONE_BRICK_" + variantSuffix);
        }
        // QUARTZ_BLOCK has QUARTZ_STAIRS / QUARTZ_SLAB (no wall)
        if (b.equals("QUARTZ_BLOCK")) {
            if (variantSuffix.equals("STAIRS")) return Material.matchMaterial("QUARTZ_STAIRS");
            if (variantSuffix.equals("SLAB"))   return Material.matchMaterial("QUARTZ_SLAB");
            return null;
        }
        // Most others try simple suffix
        Material m = Material.matchMaterial(b + "_" + variantSuffix);
        return m; // may be null if variant doesn’t exist
    }

}
